#!/usr/bin/python2.4
# vim:ts=4:sw=4:softtabstop=4:smarttab:expandtab
# 
# $Id$
#
#    Copyright (C) 1999-2006  Keith Dart <keith@kdart.com>
#
#    This library is free software; you can redistribute it and/or
#    modify it under the terms of the GNU Lesser General Public
#    License as published by the Free Software Foundation; either
#    version 2.1 of the License, or (at your option) any later version.
#
#    This library is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#    Lesser General Public License for more details.

"""This package has constants and methods to fetch standard ISO defined
constant values. 

languagecodes: "http://www.loc.gov/standards/iso639-2/englangn.html"

"""

import os

URLS = {
"countrycodes": "http://www.iso.ch/iso/en/prods-services/iso3166ma/02iso-3166-code-lists/list-en1-semic.txt",
"countrycodesfile": os.path.join("/", "etc", "pycopia", "iso3166-1.txt"),
"languagecodes": "file://%s" % (os.path.join("/", "etc", "pycopia", "iso639a.txt")),
"languagecodes8bit": "http://www.loc.gov/standards/iso639-2/ISO-639-2_values_8bits-utf-8.txt",
}

# To read this file, please note that one line of text contains one entry.
# An alpha-3 (bibliographic) code, an alpha-3 (terminologic) code (when
# given), an alpha-2 code (when given), an English name, and a French name
# of a language are all separated by pipe (|) characters. The Line
# terminator is the LF character.

def build_iso639a(filename):
    import urllib2
    url = URLS["languagecodes8bit"]
    req = urllib2.Request(url, None)
    req.add_header("User-Agent",'Mozilla/5.0 (Pycopia)')
    req.add_header("Accept", "text/plain")
    req.add_header("Accept-Charset", "iso-8859-1,utf-8")
    req.add_header("Accept-Language", "*")
    ccf = urllib2.urlopen(req)

    outf = open(filename, "w")
    outf.write("""#!/usr/bin/python2.4
# -*- coding: utf-8 -*-
# generated by build_iso639a()

""")
    outf.write("LANGUAGECODES = {\n")

    for line in ccf.readlines():
        parts = line.split("|")
        if len(parts) != 5:
            continue
        [alpha3_bib, alpha3_term, alpha2, name_en, name_fr] = map(str.strip, parts)
        if alpha2:
            name_en = unicode(name_en, 'utf-8')
            outf.write("  %r: %r,\n" % (alpha2.lower(), name_en.capitalize()))
    outf.write("}\n\n")
    outf.close()
    ccf.close()


def build_iso639a_old(filename):
    """Rebuild the iso639a (language code) module from a URL. """
    import urllib2
    outf = open(filename, "w")
    outf.write("#!/usr/bin/python\n\n# generated by build_iso639a()\n\n")
    outf.write("LANGUAGECODES = {\n")

    ccf = urllib2.urlopen(URLS["languagecodes"])
    ccf.readline() # eat first header line
    for line in ccf.readlines():
        vals = line.strip().split(None, 2)
        if len(vals) != 3 or len(vals[1]) != 2:
            continue
        outf.write("  %r: %r,\n" % (vals[1].lower(), vals[0].capitalize()))
    outf.write("}\n\n")
    outf.close()
    ccf.close()

def build_iso3166(filename):
    """Rebuild the iso3166 (country code) module from the URL. """
    import urllib2
    outf = open(filename, "w")

    outf.write("""#!/usr/bin/python
# -*- coding: iso-8859-1 -*-
# generated by build_iso3166()

""")
    outf.write("COUNTRYCODES = {\n")
    try:
        ccf = urllib2.urlopen(URLS["countrycodes"])
    except:
        print "Could not get country codes from %r, using local file." % (URLS["countrycodes"],)
        ccf = open(URLS["countrycodesfile"])
    ccf.readline() # eat first header line
    for line in ccf.readlines():
        vals = line.strip().split(";")
        if len(vals) != 2:
            continue
        outf.write("  %r: %r,\n" % (vals[1], vals[0]))
    outf.write("}\n\n")
    outf.close()
    ccf.close()

